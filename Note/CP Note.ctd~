<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node name="CP" unique_id="1" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1664051667" ts_lastsave="1669300335">
    <node name="Math" unique_id="3" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1665134577" ts_lastsave="1672604148">
      <node name="Modular Arithmetic" unique_id="2" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1664057310" ts_lastsave="1672522323">
        <rich_text>Modular arithmetic is the branch of arithmetic mathematics related with the “mod” functionality. Basically, modular arithmetic is related with computation of “mod” of expressions. Expressions may have digits and computational symbols of addition, subtraction, multiplication, division or any other.	
	
</rich_text>
        <rich_text weight="heavy">Quotient Remainder Theorem:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">a = b x q + r where 0 &lt;= r &lt; b</rich_text>
        <rich_text>
	
</rich_text>
        <rich_text weight="heavy">Modular Addition:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">(a + b) % m = ((a % m) + (b % m)) % m</rich_text>
        <rich_text>
	
</rich_text>
        <rich_text weight="heavy">Modular Substraction:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">((-b) % m) = (((- b) % m) + m) % m</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">(a - b) % m = ((a % m) + ((-b) % m)) % m</rich_text>
        <rich_text>
	
</rich_text>
        <rich_text weight="heavy">Modular Multiplication:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">(a x b) % m = ((a % m) x (b % m)) % m</rich_text>
        <rich_text>
	
</rich_text>
        <rich_text weight="heavy">Modular Division:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">(a / b) % m = (a x (inverse of b if exists)) % m
</rich_text>
        <rich_text>
</rich_text>
        <rich_text weight="heavy">Moduler Inverse:</rich_text>
        <rich_text>
	The modular inverse of </rich_text>
        <rich_text family="monospace">a mod m</rich_text>
        <rich_text> exists only if a and m are relatively prime i.e. </rich_text>
        <rich_text family="monospace">gcd(a, m) = 1</rich_text>
        <rich_text>. Hence, for finding the inverse of an under modulo m, if </rich_text>
        <rich_text family="monospace">(a x b) % m = 1</rich_text>
        <rich_text> then b is the modular inverse of a.
	Example: a = 5, m = 7, (a x b) % m = (5 x 3) % 7 = 1 hence, b=3 is modulo inverse of 5 under 7.
		Programetically we can </rich_text>
        <rich_text weight="heavy">Bruteforce</rich_text>
        <rich_text> b from 1 to m-1 and check for which b, (a x b) % m = 1.
		
	</rich_text>
        <rich_text weight="heavy">Fermat's Little Theorem:</rich_text>
        <rich_text>
		Let </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text> be a prime which does not divide the integer </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text>, then </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text family="monospace" scale="sup">p-1</rich_text>
        <rich_text family="monospace"> ≡ 1 (mod p)</rich_text>
        <rich_text>.
		</rich_text>
        <rich_text weight="heavy">Proof:</rich_text>
        <rich_text>
			Start by listing the first p-1 positive multiples of a: </rich_text>
        <rich_text family="monospace">a, 2a, 3a, ... (p -1)a</rich_text>
        <rich_text>
			Suppose that </rich_text>
        <rich_text family="monospace">ra</rich_text>
        <rich_text> and </rich_text>
        <rich_text family="monospace">sa</rich_text>
        <rich_text> are the same </rich_text>
        <rich_text family="monospace">modulo p</rich_text>
        <rich_text>, then we have </rich_text>
        <rich_text family="monospace">r = s (mod p)</rich_text>
        <rich_text>, so the p-1 multiples of a above are distinct and nonzero; that is, they must be congruent to </rich_text>
        <rich_text family="monospace">1, 2, 3, ..., p-1</rich_text>
        <rich_text> in some order. That means for prime </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text>, </rich_text>
        <rich_text family="monospace">modulo p</rich_text>
        <rich_text> of </rich_text>
        <rich_text family="monospace">1</rich_text>
        <rich_text> to </rich_text>
        <rich_text family="monospace">p-1</rich_text>
        <rich_text> multiplies of </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text> [</rich_text>
        <rich_text family="monospace">a, 2a, 3a, ... (p -1)a</rich_text>
        <rich_text>] will be distinct [</rich_text>
        <rich_text family="monospace">1, 2, 3, ..., p-1</rich_text>
        <rich_text>] for each multiplies in random order.
			Now multiply all these congruences together and we find,
				</rich_text>
        <rich_text family="monospace">a (2a) (3a) ... ((p-1)a) ≡ 1.2.3.....(p-1) (mod p)</rich_text>
        <rich_text>
				</rich_text>
        <rich_text family="monospace">=&gt; a</rich_text>
        <rich_text family="monospace" scale="sup">p-1</rich_text>
        <rich_text family="monospace"> (p-1)! ≡ (p-1)! (mod p)</rich_text>
        <rich_text>
				</rich_text>
        <rich_text family="monospace">=&gt; a</rich_text>
        <rich_text family="monospace" scale="sup">p-1</rich_text>
        <rich_text family="monospace"> ≡ 1 (mod p)</rich_text>
        <rich_text>  [Divide both side by (p-1)!]
					[Proved]
	</rich_text>
        <rich_text weight="heavy">Modulo Inverse Under Prime Modulo:</rich_text>
        <rich_text>
		For prime </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text>, </rich_text>
        <rich_text family="monospace">a x (1/a) = 1 (mod p)</rich_text>
        <rich_text> [</rich_text>
        <rich_text family="monospace">a x (1/a) = 1</rich_text>
        <rich_text>]. So </rich_text>
        <rich_text family="monospace">(1/a)</rich_text>
        <rich_text> is the modulo inverse of </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text> under </rich_text>
        <rich_text family="monospace">modulo p</rich_text>
        <rich_text>.
		From Fermat's Little Theorem,
			</rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text family="monospace" scale="sup">p-1</rich_text>
        <rich_text family="monospace"> ≡ 1 (mod p)</rich_text>
        <rich_text>
			</rich_text>
        <rich_text family="monospace">=&gt; a</rich_text>
        <rich_text family="monospace" scale="sup">p-2</rich_text>
        <rich_text family="monospace">	≡ (1/a) (mod p)</rich_text>
        <rich_text>
			Hence, modulo inverse of </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text> under </rich_text>
        <rich_text family="monospace">modulo p</rich_text>
        <rich_text> is </rich_text>
        <rich_text family="monospace">(a</rich_text>
        <rich_text family="monospace" scale="sup">p-2</rich_text>
        <rich_text family="monospace"> mod p)</rich_text>
        <rich_text>.
			So, moduler division for prime modulo </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text>, </rich_text>
        <rich_text family="monospace">(a/b) mod p = (a * (b</rich_text>
        <rich_text family="monospace" scale="sup">p-2</rich_text>
        <rich_text family="monospace"> mod p)) mod p</rich_text>
        <rich_text>
			
	
</rich_text>
        <rich_text weight="heavy">Modular Exponentiation (Big Mod):</rich_text>
        <rich_text>
	Finding </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text family="monospace" scale="sup">n</rich_text>
        <rich_text family="monospace"> mod m</rich_text>
        <rich_text> is the modular exponentiation. </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text family="monospace" scale="sup">n</rich_text>
        <rich_text> where a and n are large that </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text family="monospace" scale="sup">n</rich_text>
        <rich_text> won't fit in long long integer, that's why doing mod won't help.
	To solve this problem we can use </rich_text>
        <rich_text style="italic" weight="heavy">Bruteforce</rich_text>
        <rich_text> technique to iterate over n and multiply a and doing mod [</rich_text>
        <rich_text family="monospace">ans = (ans * a) mod m</rich_text>
        <rich_text>]. But cpmpexity of this is O(n). But we can reduce the complexity to log</rich_text>
        <rich_text scale="sub">2</rich_text>
        <rich_text>(n). 
		a</rich_text>
        <rich_text scale="sup">100</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">50</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">50</rich_text>
        <rich_text>
		a</rich_text>
        <rich_text scale="sup">50</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">25</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">25</rich_text>
        <rich_text>
		a</rich_text>
        <rich_text scale="sup">25</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">12</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">12</rich_text>
        <rich_text> * a
		a</rich_text>
        <rich_text scale="sup">12</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">6</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">6</rich_text>
        <rich_text>
		a</rich_text>
        <rich_text scale="sup">6</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">3</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">3</rich_text>
        <rich_text>
		a</rich_text>
        <rich_text scale="sup">3</rich_text>
        <rich_text> = a</rich_text>
        <rich_text scale="sup">1</rich_text>
        <rich_text> * a</rich_text>
        <rich_text scale="sup">1</rich_text>
        <rich_text> * a
	At every step we reduce </rich_text>
        <rich_text style="italic" weight="heavy">n</rich_text>
        <rich_text> to </rich_text>
        <rich_text style="italic" weight="heavy">n/2</rich_text>
        <rich_text>.
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Related Problem:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic" weight="heavy">1. Print the last k digit of a</rich_text>
        <rich_text style="italic" scale="sup" weight="heavy">n</rich_text>
        <rich_text style="italic" weight="heavy"> (in decimal).</rich_text>
        <rich_text>
		Solution: Procedure is same as modular exponentiation but we have to mod it with 10</rich_text>
        <rich_text scale="sup">k</rich_text>
        <rich_text>.
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

	</rich_text>
        <rich_text style="italic" weight="heavy">2. Print the last k digit of a</rich_text>
        <rich_text style="italic" scale="sup" weight="heavy">n</rich_text>
        <rich_text style="italic" weight="heavy"> (in binary).</rich_text>
        <rich_text>
		Solution: Procedure is same as above but we have to mod it with 2</rich_text>
        <rich_text scale="sup">k</rich_text>
        <rich_text>.
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

	</rich_text>
        <rich_text style="italic" weight="heavy">3. Print something modulo 2</rich_text>
        <rich_text style="italic" scale="sup" weight="heavy">32</rich_text>
        <rich_text style="italic" weight="heavy"> or modulo 2</rich_text>
        <rich_text style="italic" scale="sup" weight="heavy">64</rich_text>
        <rich_text style="italic" weight="heavy">.</rich_text>
        <rich_text>
		Solution: Taking all the veriable as </rich_text>
        <rich_text style="italic" weight="heavy">unsigned int</rich_text>
        <rich_text> related to the calculation will give modulo 2</rich_text>
        <rich_text scale="sup">32</rich_text>
        <rich_text>. It is safe to take all the veriable as unsigned int. 			Similarly, tking all the veriable as </rich_text>
        <rich_text style="italic" weight="heavy">unsigned long long int</rich_text>
        <rich_text> related to the calculation will give modulo 2</rich_text>
        <rich_text scale="sup">64</rich_text>
        <rich_text>. We don't have to mod separately.
		</rich_text>
        <rich_text family="monospace">modulo 2</rich_text>
        <rich_text family="monospace" scale="sup">32</rich_text>
        <rich_text family="monospace"> → unsigned int
</rich_text>
        <rich_text>		</rich_text>
        <rich_text family="monospace">modulo 2</rich_text>
        <rich_text family="monospace" scale="sup">64</rich_text>
        <rich_text family="monospace"> → unsigned long long int</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic" weight="heavy">4. Multiply large integers under large modulo or avoid overflow in modular multiplication</rich_text>
        <rich_text weight="heavy">.</rich_text>
        <rich_text>
		Solution: Given an integer a, b, m. Find (a * b ) mod m, where a, b may be large and their direct multiplication may cause overflow. Therefore we use the basic approach of multiplication i.e., a * b = a + a + … + a (b times). Now easily compute the value of addition (under modulo m) without any overflow in the calculation. If we use </rich_text>
        <rich_text weight="heavy">Bruteforce</rich_text>
        <rich_text> apprach for adding </rich_text>
        <rich_text family="monospace">a</rich_text>
        <rich_text> </rich_text>
        <rich_text family="monospace">b</rich_text>
        <rich_text> times time complexity will be O(b). But we can reduce the complexity to O(log b) using the same technique we used in modular exponentiation. But insted of multiplying we will adding.
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
		
	
</rich_text>
        <rich_text weight="heavy">Important Propertice:</rich_text>
        <rich_text>
	1. </rich_text>
        <rich_text family="monospace">(a % b) = a - floor(a / b) * b</rich_text>
        <rich_text>
	2. </rich_text>
        <rich_text family="monospace">(x % 2</rich_text>
        <rich_text family="monospace" scale="sup">k</rich_text>
        <rich_text family="monospace">) = x &amp; (2</rich_text>
        <rich_text family="monospace" scale="sup">k</rich_text>
        <rich_text family="monospace"> - 1) = x &amp; ((1 &lt;&lt; k) - 1)</rich_text>
        <rich_text>
	
	</rich_text>
        <rich_text style="italic" weight="heavy">N.B. Here % means mod.</rich_text>
        <rich_text>
	
	
</rich_text>
        <codebox char_offset="2769" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">long long int power(long long int a, long long int n, long long int mod)
{
	long long int x;
	if (n == 1)
		return a % mod;
	x = recursive_power(a, n / 2);
	if (n % 2)
		return (((x * x) % mod) * a) % mod;
	else
		return (x * x) % mod;
}</codebox>
        <codebox char_offset="2942" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

long long int power(long long int a, long long int n, long long int mod)
{
	long long int x;
	if (n == 1)
		return a % mod;

	x = power(a, n / 2, mod);
	if (n % 2)
		return (((x * x) % mod) * a) % mod;
	else
		return (x * x) % mod;
}

int numberOfDigits(long long int n)
{
	int cnt = 0;
	while (n)
	{
		n /= 10;
		cnt++;
	}
	return cnt;
}

void last_k_digit(long long int a, long long int n, long long int k)
{
	long long int mod = 1, digit;
	for (int i = 0; i &lt; k; i++)
		mod *= 10; // mod=10^k

	digit = power(a, n, mod);
	for (int i = 0; i &lt; k - numberOfDigits(digit); i++)
		cout &lt;&lt; 0;
	if (digit)
		cout &lt;&lt; digit &lt;&lt; endl;
}

int main()
{
	long long int a, n, k;
	a = 3, n = 100000, k = 9; // Last k digit of a^n

	// Decimal form
	last_k_digit(a, n, k);

	return 0;
}</codebox>
        <codebox char_offset="3079" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">long long int last_k_digit_binary(long long int a, long long int n, long long int k)
{
	long long int x;
	if (n == 1)
		return a % mod;

	x = last_k_digit_binary(a, n / 2, k);
	// If we use % sign we have to use 2^k = (1&lt;&lt;k), or if we use &amp; then we have to use (2^k)-1 = (1&lt;&lt;k)-1
	if (n % 2)
		return (((x * x) % (1 &lt;&lt; k)) * a) % (1 &lt;&lt; k);
	else
		return (x * x) % (1 &lt;&lt; k);
}</codebox>
        <codebox char_offset="4157" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">long long int multiplication_mod(long long int a, long long int b, long long int mod)
{
	long long int x;
	if (b == 1)
		return a % mod;

	x = multiplication_mod(a, b / 2, mod);
	if (b % 2)
		return (((x + x) % mod) + a) % mod;
	else
		return (x + x) % mod;
}</codebox>
      </node>
      <node name="Combinatorics" unique_id="4" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1665134617" ts_lastsave="1665134649">
        <node name="Permutation" unique_id="5" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1665134633" ts_lastsave="1665134633"/>
        <node name="Combination" unique_id="6" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1665134649" ts_lastsave="1665136228"/>
      </node>
      <node name="Digital Root" unique_id="7" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1666190385" ts_lastsave="1666193949">
        <rich_text>The digital root (also repeated digital sum) of a natural number in a given radix is the (single digit) value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute a digit sum. The process continues until a single-digit number is reached. For example, in base 10, the digital root of the number 12345 is 6 because the sum of the digits in the number is 1 + 2 + 3 + 4 + 5 = 15, then the addition process is repeated again for the resulting number 15, so that the sum of 1 + 5 equals 6, which is the digital root of that number. In base 10, this is equivalent to taking the remainder upon division by 9 (except when the digital root is 9, where the remainder upon division by 9 will be 0), which allows it to be used as a divisibility rule. 

</rich_text>
        <rich_text weight="heavy">Propertise:</rich_text>
        <rich_text>
   •   If we multiply any number by 9, the digital root will always be 9.     
   •   Adding 9 to a number does not change the digital root of that number.     
   •   If we divide any number by 9, the digital root of that number will be the remainder. 
  
</rich_text>
        <rich_text weight="heavy">Formula:</rich_text>
        <rich_text>
	DR</rich_text>
        <rich_text family="monospace">(x)=(x−1) mod 9+1</rich_text>
      </node>
      <node name="Divisor" unique_id="10" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1669301502" ts_lastsave="1672522324">
        <rich_text weight="heavy">Divisor:</rich_text>
        <rich_text> In mathematics, a divisor of an integer </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>, also called a factor of </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>, is an integer </rich_text>
        <rich_text family="monospace">m</rich_text>
        <rich_text> that may be multiplied by some integer to produce </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>. In this case, one also says that </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> is a multiple of </rich_text>
        <rich_text family="monospace">m</rich_text>
        <rich_text>. An integer </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> is divisible or evenly divisible by another integer </rich_text>
        <rich_text family="monospace">m</rich_text>
        <rich_text> if </rich_text>
        <rich_text family="monospace">m</rich_text>
        <rich_text> is a divisor of </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>; this implies dividing </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> by </rich_text>
        <rich_text family="monospace">m</rich_text>
        <rich_text> leaves no remainder.

</rich_text>
        <rich_text weight="heavy">Enumerating Divisors</rich_text>
        <rich_text>
	If we have to find the divisors of </rich_text>
        <rich_text weight="heavy">n</rich_text>
        <rich_text>, we only have to enamurate till </rich_text>
        <rich_text family="monospace">√n</rich_text>
        <rich_text>.
	
	Suppose take </rich_text>
        <rich_text family="monospace">n=36</rich_text>
        <rich_text>,
		</rich_text>
        <rich_text family="monospace">1 X 36</rich_text>
        <rich_text>
		</rich_text>
        <rich_text family="monospace">2 X 18</rich_text>
        <rich_text>
		</rich_text>
        <rich_text family="monospace">3 X 12</rich_text>
        <rich_text>
		</rich_text>
        <rich_text family="monospace">4 X 9</rich_text>
        <rich_text>
		</rich_text>
        <rich_text family="monospace">6 X 6</rich_text>
        <rich_text>
		So the divisors are </rich_text>
        <rich_text family="monospace">1, 2, 3, 4, 6, 9, 12, 18, 36</rich_text>
        <rich_text> and </rich_text>
        <rich_text family="monospace">√36 = 6</rich_text>
        <rich_text>.
		Terefore if we enamurate till  </rich_text>
        <rich_text family="monospace">√n</rich_text>
        <rich_text> we will be able to find all the divisors of </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>.
		Complexity: </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
	
</rich_text>
        <rich_text weight="heavy">Odd Number of Divisors</rich_text>
        <rich_text>
	The </rich_text>
        <rich_text family="monospace" style="italic" weight="heavy">SQUARE</rich_text>
        <rich_text> numbers has only odd number of divisors.

	For example,
	</rich_text>
        <rich_text justification="fill"></rich_text>
        <rich_text>
	From the table we can see that only square numbers 1, 4, 9 has odd numbers of divisors.

</rich_text>
        <rich_text weight="heavy">Number of Divisors:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text weight="heavy">Enamurate:</rich_text>
        <rich_text>
		Enamurate the divisors of n and return the count.
		Complexity: </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
	
	</rich_text>
        <rich_text weight="heavy">Using Prime Fectorization:</rich_text>
        <rich_text>	
		It should be obvious that the prime factorization of a divisor  </rich_text>
        <rich_text family="monospace">d</rich_text>
        <rich_text>  has to be a subset of the prime factorization of  </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> , e.g.  </rich_text>
        <rich_text family="monospace">6=2.3</rich_text>
        <rich_text>  is a divisor of  </rich_text>
        <rich_text family="monospace">60=2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">.3.5</rich_text>
        <rich_text> . So we only need to find all different subsets of the prime factorization of  </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> . So if a prime factor  </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text>  appears  </rich_text>
        <rich_text family="monospace">e</rich_text>
        <rich_text>  times in the prime factorization of  </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> , then we can use the factor  </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text>  up to  </rich_text>
        <rich_text family="monospace">e</rich_text>
        <rich_text>  times in the subset. Which means we have  </rich_text>
        <rich_text family="monospace">e+1</rich_text>
        <rich_text>  choices.
		Therefore if the prime factorization of  </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>  is </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text family="monospace">.p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace" scale="sup">e2</rich_text>
        <rich_text family="monospace">....p</rich_text>
        <rich_text family="monospace" scale="sub">k</rich_text>
        <rich_text family="monospace" scale="sup">ek</rich_text>
        <rich_text scale="sup"> </rich_text>
        <rich_text>, where  </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text family="monospace" scale="sub">i</rich_text>
        <rich_text>  are distinct prime numbers, then the number of divisors is:
			</rich_text>
        <rich_text family="monospace">NOD(n)=(e</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace">+1).(e</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace">+1)...(e</rich_text>
        <rich_text family="monospace" scale="sub">k</rich_text>
        <rich_text family="monospace">+1)</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>					
	
	</rich_text>
        <rich_text weight="heavy">Using Sieve of Eratosthenes:</rich_text>
        <rich_text>
		It is based on seive agorithm.
		Complexity: </rich_text>
        <rich_text family="monospace">O(n log(log(n)))</rich_text>
        <rich_text>
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
	
	</rich_text>
        <rich_text weight="heavy">Upper Bound of Number of Divisors:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">NOD(n) ≤ n</rich_text>
        <rich_text>
	Further  improvement, </rich_text>
        <rich_text family="monospace">NOD(n) ≤ (n/2)+1</rich_text>
        <rich_text>
	Further  improvement, </rich_text>
        <rich_text family="monospace">NOD(n) ≤ 2.√n</rich_text>
        <rich_text>
	Further  improvement, </rich_text>
        <rich_text family="monospace">NOD(n) ≈ 2.</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">√n</rich_text>
        <rich_text>
	</rich_text>
        <rich_text family="monospace">2.</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">√n</rich_text>
        <rich_text> can be used safely as the upper bound of </rich_text>
        <rich_text family="monospace">NOD</rich_text>
        <rich_text>. Apparently, this approximation has been tested for </rich_text>
        <rich_text family="monospace">N≤10</rich_text>
        <rich_text family="monospace" scale="sup">18</rich_text>
        <rich_text>, which is large enough to be used in programming contests.
		
</rich_text>
        <rich_text weight="heavy">Sum of Divisors:</rich_text>
        <rich_text>

	</rich_text>
        <rich_text weight="heavy">Using Prime Fectorization:</rich_text>
        <rich_text>
		Using prime fectorization concept sum of the divisors can be found very easily. 
		If only prime fector on </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> is </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text> then the divisors are </rich_text>
        <rich_text family="monospace">1, p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace">, p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace"> , p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">, .... p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text>. Then sum of the divisors is </rich_text>
        <rich_text family="monospace">1+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">+....+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text family="monospace"> = (p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1+1</rich_text>
        <rich_text family="monospace">-1)/(p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace">-1)</rich_text>
        <rich_text>.
		If the prime fectorization of </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text> is </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text family="monospace">.p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace" scale="sup">e2</rich_text>
        <rich_text> then the sum of the divisors is </rich_text>
        <rich_text family="monospace">(1+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">+....+p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1</rich_text>
        <rich_text family="monospace">).(1+p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">+p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">+....+p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace" scale="sup">e2</rich_text>
        <rich_text family="monospace">) = ((p</rich_text>
        <rich_text family="monospace" scale="sub">1</rich_text>
        <rich_text family="monospace" scale="sup">e1+1</rich_text>
        <rich_text family="monospace">-1)/(p</rich_text>
        <rich_text family="monospace" scale="sup">1</rich_text>
        <rich_text family="monospace">-1)).((p2</rich_text>
        <rich_text family="monospace" scale="sup">e2+1</rich_text>
        <rich_text family="monospace">-1)/(p</rich_text>
        <rich_text family="monospace" scale="sub">2</rich_text>
        <rich_text family="monospace">-1))</rich_text>
        <rich_text>.
		A similar argument can be made if there are more then two distinct prime factors.
	
	</rich_text>
        <rich_text weight="heavy">Using Sieve of Eratosthenes:</rich_text>
        <rich_text>
		It is based on seive agorithm.
		Complexity: </rich_text>
        <rich_text family="monospace">O(n log(log(n)))</rich_text>
        <rich_text>
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
	
	
	
</rich_text>
        <rich_text weight="heavy">Related Problem:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic" weight="heavy">1. Find the numbers under n which has odd number of divisors.</rich_text>
        <rich_text>
		Solution: The number would be 1 to square root of n.
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>
	
	</rich_text>
        <rich_text weight="heavy">2. Which number has exactly 3 divisors?</rich_text>
        <rich_text>				
	Solution: The square of a prime number has only exactly 3 divisors. According to prime fectorization if and only if </rich_text>
        <rich_text family="monospace">n=p</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text> only then </rich_text>
        <rich_text family="monospace">NOD(n)=(2+1)=3</rich_text>
        <rich_text>, where </rich_text>
        <rich_text family="monospace">p</rich_text>
        <rich_text> is the prime fector of </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>.
	
	</rich_text>
        <rich_text weight="heavy">3. Which number has exactly 4 divisors?</rich_text>
        <rich_text>
	Solution: The qube of a prime number or multiplication of 2 prime number has only 4 divisors. According to prime fectorization if </rich_text>
        <rich_text family="monospace">n=p</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text> or </rich_text>
        <rich_text family="monospace">n=p.q</rich_text>
        <rich_text> only then </rich_text>
        <rich_text family="monospace">NOD(n)=(3+1)=4</rich_text>
        <rich_text> or </rich_text>
        <rich_text family="monospace">NOD(n)=(1+1).(1+1)=(2.2)=4</rich_text>
        <rich_text>.</rich_text>
        <codebox char_offset="690" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">void (long long int n)
{
	for (ll i = 1; i * i &lt;= n; i++) // i * i &lt;= n is same as i &lt;= sqrt(n) but not safe because of double precision
	{
		if (n % i == 0)
		{
			cout &lt;&lt; i &lt;&lt; " ";
			if (n / i != i)
				cout &lt;&lt; (n / i) &lt;&lt; " ";
		}
	}
}</codebox>
        <table char_offset="786" justification="fill" col_min="70" col_max="70" col_widths="0,75,0">
          <row>
            <cell>1</cell>
            <cell>1</cell>
            <cell>1</cell>
          </row>
          <row>
            <cell>2</cell>
            <cell>1, 2</cell>
            <cell>2</cell>
          </row>
          <row>
            <cell>3</cell>
            <cell>1, 3</cell>
            <cell>2</cell>
          </row>
          <row>
            <cell>4</cell>
            <cell>1, 2, 4</cell>
            <cell>3</cell>
          </row>
          <row>
            <cell>5</cell>
            <cell>1, 5</cell>
            <cell>2</cell>
          </row>
          <row>
            <cell>6</cell>
            <cell>1, 2, 3, 6</cell>
            <cell>4</cell>
          </row>
          <row>
            <cell>7</cell>
            <cell>1, 7</cell>
            <cell>2</cell>
          </row>
          <row>
            <cell>8</cell>
            <cell>1, 2, 4, 8</cell>
            <cell>4</cell>
          </row>
          <row>
            <cell>9</cell>
            <cell>1, 3, 9</cell>
            <cell>3</cell>
          </row>
          <row>
            <cell>10</cell>
            <cell>1, 2, 5, 10</cell>
            <cell>4</cell>
          </row>
          <row>
            <cell>--Number--</cell>
            <cell>--Divisors--</cell>
            <cell>--Count--</cell>
          </row>
        </table>
        <codebox char_offset="1000" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">int NOD(int n)
{
	int nod=0;
	for (ll i = 1; i * i &lt;= n; i++)
	{
		if (n % i == 0)
		{
			nod++;
			if (n / i != i)
				nod++;
		}
	}
	return nod;
}</codebox>
        <codebox char_offset="1629" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">int NODPF(int n)
{
	int nod=0, p;
	for (ll i = 2; i * i &lt;= n; i++)
	{
		if (n % i == 0)
		{
			p = 0;
			while (n % i == 0)
				p++, n /= i;
			p++;
			nod *= p;
		}
	}

	if (n &gt; 1)
		nod *= 2;

	return nod;
}</codebox>
        <codebox char_offset="1750" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

int main()
{
	ll n;
	cin &gt;&gt; n;
	vector&lt;ll&gt; nod(n + 10);

	// .for (ll i = 1; i &lt;= n; i++)
	//  	for (ll j = 1; i * j &lt;= n; j++)
	//  		nod[i * j]++;

	// More optimized but little bit complex to understand
	for (ll i = 1; i * i &lt;= n; i++)
	{
		for (ll j = i; i * j &lt;= n; j++)
		{
			if (i == j)
				nod[i * j]++;
			else
				nod[i * j] += 2;
		}
	}

	for (ll i = 1; i &lt;= n; i++)
		cout &lt;&lt; i &lt;&lt; " --&gt; " &lt;&lt; nod[i] &lt;&lt; endl;

	return 0;
}</codebox>
        <codebox char_offset="2748" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

int main()
{
	ll n;
	cin &gt;&gt; n;
	vector&lt;ll&gt; sod(n + 10);

	//..	for (ll i = 1; i &lt;= n; i++)
	//..		for (ll j = 1; i * j &lt;= n; j++)
	//..			sod[i * j] += i;

	// More optimized but little bit complex to understand
	for (ll i = 1; i * i &lt;= n; i++)
	{
		for (ll j = i; i * j &lt;= n; j++)
		{
			if (i == j)
				sod[i * j]+=i;
			else
				sod[i * j] += (i+j);
		}
	}

	for (ll i = 1; i &lt;= n; i++)
		cout &lt;&lt; i &lt;&lt; " --&gt; " &lt;&lt; sod[i] &lt;&lt; endl;

	return 0;
}</codebox>
        <codebox char_offset="2909" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
	int n;
	cin &gt;&gt; n;

	cout &lt;&lt; "Count of numbers till " &lt;&lt; n &lt;&lt; " which has odd number of divisors: " &lt;&lt; sqrt(n) &lt;&lt; endl;
	cout &lt;&lt; "The numbers are: ";
	for (int i = 1; i * i &lt;= n; i++) // i * i &lt;= n is same as i &lt;= sqrt(n) but not safe because of double precision
		cout &lt;&lt; i &lt;&lt; " ";

	return 0;
}</codebox>
      </node>
      <node name="Prime" unique_id="11" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1669741489" ts_lastsave="1672522371">
        <rich_text weight="heavy">Prime Number:</rich_text>
        <rich_text> A prime number (or a prime) is a natural number greater than 1 that is not a product of two smaller natural numbers.
	For example, 5 is prime because the only ways of writing it as a product, 1 × 5 or 5 × 1, involve 5 itself. 

</rich_text>
        <rich_text weight="heavy">Composite number:</rich_text>
        <rich_text> A natural number greater than 1 that is not prime is called a composite number.
	For example, 4 is composite because it is a product (2 × 2) in which both numbers are smaller than 4. 
 
</rich_text>
        <rich_text weight="heavy">Fundamental Theorem of Arithmetic:</rich_text>
        <rich_text> Every natural number greater than 1 is either a prime itself or can be factorized as a product of primes that is unique up to their order.
	For example, </rich_text>
        <rich_text family="monospace">12 = 2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace"> = (2.2).(3.3)</rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Miserable Fate of 1:</rich_text>
        <rich_text> 1 is not a prime number. Because it doesn't have exactly 2 divisors. If 1 were a prime number there would be Chaos! Because then every number could have represented using product of primes in different ways. For example: </rich_text>
        <rich_text family="monospace">6 = 2⋅3 = 2⋅3⋅1 = 2⋅3⋅1⋅1….</rich_text>
        <rich_text> You got the idea right? 1 is not a composite number(according to Wiki) either. Because it has less than 2 divisors.

</rich_text>
        <rich_text weight="heavy">Primality Test:</rich_text>
        <rich_text>
	To check if a number is prime or not, we just have to check if a number between </rich_text>
        <rich_text family="monospace">2</rich_text>
        <rich_text> to </rich_text>
        <rich_text family="monospace">√n</rich_text>
        <rich_text> (inclding) divides the n.
	Complexity: </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Smallest Prime Factor(SPF):</rich_text>
        <rich_text> 
	The </rich_text>
        <rich_text style="italic">smallest</rich_text>
        <rich_text> number greater than 1 that divides n is also the smallest prime factor of n.
	Complexity: </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Prime Fectorization:</rich_text>
        <rich_text>
	Prime factorization is the decomposition of a number into a product of smaller prime numbers.
	The implementation is same as the smallest prime fector, just remove the fector from n and repeat the process.
	Complexity: </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Sieve of Eratosthenes:</rich_text>
        <rich_text>
	It is an easy and efficient way to find all the prime number under a specific number. 
	</rich_text>
        <rich_text weight="heavy">Procedure:</rich_text>
        <rich_text>
		1. The number which are devided by the current (For the initial its the first prime) prime,  flag them.
		2. The next unflaged unmber would be current prime. Repeat the step 1 till square root of n
		
		Complexity: </rich_text>
        <rich_text family="monospace">O(n log(log(n)))</rich_text>
        <rich_text>
		</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
		</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Prime Gap:</rich_text>
        <rich_text>
	A prime gap is the difference between two successive prime numbers. The n-th prime gap, denoted </rich_text>
        <rich_text family="monospace">g</rich_text>
        <rich_text family="monospace" scale="sub">n </rich_text>
        <rich_text>or </rich_text>
        <rich_text family="monospace">g(p</rich_text>
        <rich_text family="monospace" scale="sub">n</rich_text>
        <rich_text family="monospace">)</rich_text>
        <rich_text> is the difference between the </rich_text>
        <rich_text family="monospace">(n + 1)</rich_text>
        <rich_text>-th and the </rich_text>
        <rich_text family="monospace">n</rich_text>
        <rich_text>-th prime numbers, i.e. g</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text> = p</rich_text>
        <rich_text scale="sub">n + 1</rich_text>
        <rich_text> - p</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text>. We have g</rich_text>
        <rich_text scale="sub">1</rich_text>
        <rich_text> = 1, g</rich_text>
        <rich_text scale="sub">2</rich_text>
        <rich_text> = g</rich_text>
        <rich_text scale="sub">3</rich_text>
        <rich_text> = 2, and g</rich_text>
        <rich_text scale="sub">4</rich_text>
        <rich_text> = 4. The sequence (g</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text>) of prime gaps has been extensively studied; however, many questions and conjectures remain unanswered. There is no exact formula for g</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text>. Cramer's conjecture states that g</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text> ​ =O(log(p</rich_text>
        <rich_text scale="sub">n</rich_text>
        <rich_text>)</rich_text>
        <rich_text scale="sup">2</rich_text>
        <rich_text>) which is indeed very low.

</rich_text>
        <rich_text weight="heavy">Related Problem:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic" weight="heavy">1. Find the next prime number greater than </rich_text>
        <rich_text family="monospace" style="italic" weight="heavy">n</rich_text>
        <rich_text style="italic" weight="heavy"> where </rich_text>
        <rich_text family="monospace" style="italic" weight="heavy">n</rich_text>
        <rich_text style="italic" weight="heavy"> can be up to </rich_text>
        <rich_text family="monospace" style="italic" weight="heavy">10</rich_text>
        <rich_text family="monospace" style="italic" scale="sup" weight="heavy">9</rich_text>
        <rich_text style="italic" weight="heavy">.</rich_text>
        <rich_text>
	Solution: The first solution that pops up in your head is to brute force over all numbers </rich_text>
        <rich_text family="monospace">&gt;n</rich_text>
        <rich_text> until we find a prime. We can check if it is a prime or not in </rich_text>
        <rich_text family="monospace">O(√n)</rich_text>
        <rich_text>. According to Cramer's conjecture after roughly </rich_text>
        <rich_text family="monospace">Olog(10</rich_text>
        <rich_text family="monospace" scale="sup">9</rich_text>
        <rich_text family="monospace">)</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace"> ≈ 30</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace"> ≈ 900</rich_text>
        <rich_text> operation, we will hit a prime! So the complexity will be </rich_text>
        <rich_text family="monospace">O(900⋅√n)</rich_text>
        <rich_text> which is okay!
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <codebox char_offset="1213" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">bool isPrime(int n)
{
	for (int i = 2; i * i &lt;= n; i++)
		if (n % i == 0)
			return false;

	return true;
}</codebox>
        <codebox char_offset="1371" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">ll SPF(int n)
{
	for (int i = 2; i * i &lt;= n; i++)
		if (n % i == 0)
			return i;

	return n;
}</codebox>
        <codebox char_offset="1637" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
	int n, m, tmp_n;

	cin &gt;&gt; n;
	tmp_n=n;
	vector&lt;int&gt; v;
	
	for (int i = 2; i * i &lt;= n; i++)
	{
		if (n % i == 0)
		{
			while (n % i == 0)
				v.push_back(i), n /= i;
		}
	}

	if (n &gt; 1)
		v.push_back(n);

	cout &lt;&lt; "Prime fectorization of " &lt;&lt; tmp_n &lt;&lt; ": \n";
	for (auto it : v)
		cout &lt;&lt; it &lt;&lt; " ";

	return 0;
}</codebox>
        <codebox char_offset="2015" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int N = 1e8 + 9;
bool arr[N]; // Has lowest execution time compare to bitset and vector.
// bitset&lt;N&gt; arr;
// vector&lt;bool&gt; arr(N);

int main()
{
	ll n;
	cin &gt;&gt; n;
	vector&lt;ll&gt; prime;

	arr[0]=arr[1]=1;
	for(ll i=2; i*i&lt;=n; i++)
	{
		if(!arr[i])
		{
			// we can start from both j=i or j=2, using i is more optimized but it wouldn't reduce much time complexity.
			for(ll j=i; i*j&lt;=n; j++)
			arr[i*j]=1;
		}
	}

	for(ll i=0; i&lt;=n; i++) if(!arr[i]) prime.push_back(i);
	for(auto it : prime) cout &lt;&lt; it &lt;&lt; " ";
	cout &lt;&lt; endl;

	return 0;
}</codebox>
        <codebox char_offset="2925" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1"></codebox>
      </node>
      <node name="GCD and LCM" unique_id="12" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1672604148" ts_lastsave="1672866027">
        <rich_text weight="heavy">GCD:</rich_text>
        <rich_text> The greatest common divisor (GCD) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. For two integers </rich_text>
        <rich_text style="italic">x, y,</rich_text>
        <rich_text> the greatest common divisor of </rich_text>
        <rich_text style="italic">x</rich_text>
        <rich_text> and </rich_text>
        <rich_text style="italic">y</rich_text>
        <rich_text> is denoted </rich_text>
        <rich_text style="italic">gcd(x,y)</rich_text>
        <rich_text>. For example, the GCD of 8 and 12 is 4, that is, gcd(8,12)=4.
	In C++ builtin function </rich_text>
        <rich_text family="monospace">__gcd(a, b)</rich_text>
        <rich_text> used to find the gcd of a and b. 
	</rich_text>
        <rich_text style="italic" weight="heavy">Complexity:</rich_text>
        <rich_text> </rich_text>
        <rich_text family="monospace" style="italic">O</rich_text>
        <rich_text family="monospace">(log(</rich_text>
        <rich_text family="monospace" style="italic">min</rich_text>
        <rich_text family="monospace">(</rich_text>
        <rich_text family="monospace" style="italic">a</rich_text>
        <rich_text family="monospace">,</rich_text>
        <rich_text family="monospace" style="italic">b</rich_text>
        <rich_text family="monospace">)))</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">LCM:</rich_text>
        <rich_text> The least common multiple, lowest common multiple, or smallest common multiple of two integers </rich_text>
        <rich_text style="italic">a</rich_text>
        <rich_text> and </rich_text>
        <rich_text style="italic">b</rich_text>
        <rich_text>, usually denoted by </rich_text>
        <rich_text style="italic">lcm(a,b)</rich_text>
        <rich_text>, is the smallest positive integer that is divisible by both </rich_text>
        <rich_text style="italic">a</rich_text>
        <rich_text> and </rich_text>
        <rich_text style="italic">b</rich_text>
        <rich_text>.
	Suppose 
		</rich_text>
        <rich_text family="monospace">a=2</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">4</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">1</rich_text>
        <rich_text>
		</rich_text>
        <rich_text family="monospace">b=2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">5</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text>
	So, </rich_text>
        <rich_text family="monospace">gcd(a,b) = 2</rich_text>
        <rich_text family="monospace" scale="sup">min(2,3)</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">min(4,5)</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">min(1,0)</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">min(0,2)</rich_text>
        <rich_text family="monospace"> = 2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">4</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">0</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">0</rich_text>
        <rich_text>
		  </rich_text>
        <rich_text family="monospace">lcm(a,b) = 2</rich_text>
        <rich_text family="monospace" scale="sup">max(2,3)</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">max(4,5)</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">max(1,0)</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">max(0,2)</rich_text>
        <rich_text family="monospace"> = 2</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">5</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">1</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text>
	Therefore, </rich_text>
        <rich_text family="monospace">gcd(a,b).lcm(a,b) = (2</rich_text>
        <rich_text family="monospace" scale="sup">min(2,3)</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">min(4,5)</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">min(1,0)</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">min(0,2)</rich_text>
        <rich_text family="monospace">) . (2</rich_text>
        <rich_text family="monospace" scale="sup">max(2,3)</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">max(4,5)</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">max(1,0)</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">max(0,2)</rich_text>
        <rich_text family="monospace">)</rich_text>
        <rich_text> 
					</rich_text>
        <rich_text family="monospace">=&gt; gcd(a,b).lcm(a,b) = 2</rich_text>
        <rich_text family="monospace" scale="sup">2+3</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">4+5</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">0+1</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">0+2</rich_text>
        <rich_text family="monospace"> </rich_text>
        <rich_text>
					</rich_text>
        <rich_text family="monospace">=&gt; gcd(a,b).lcm(a,b) = (2</rich_text>
        <rich_text family="monospace" scale="sup">3</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">4</rich_text>
        <rich_text family="monospace">.5</rich_text>
        <rich_text family="monospace" scale="sup">1</rich_text>
        <rich_text family="monospace">).(2</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">.3</rich_text>
        <rich_text family="monospace" scale="sup">5</rich_text>
        <rich_text family="monospace">.7</rich_text>
        <rich_text family="monospace" scale="sup">2</rich_text>
        <rich_text family="monospace">)</rich_text>
        <rich_text> 
					</rich_text>
        <rich_text family="monospace">=&gt; gcd(a,b).lcm(a,b) = a.b</rich_text>
        <rich_text>
					</rich_text>
        <rich_text family="monospace">=&gt; lcm(a,b) = (a.b)/gcd(a,b)</rich_text>
        <rich_text>
	
	</rich_text>
        <rich_text style="italic" weight="heavy">Complexity:</rich_text>
        <rich_text> </rich_text>
        <rich_text family="monospace" style="italic">O</rich_text>
        <rich_text family="monospace">(log(</rich_text>
        <rich_text family="monospace" style="italic">min</rich_text>
        <rich_text family="monospace">(</rich_text>
        <rich_text family="monospace" style="italic">a</rich_text>
        <rich_text family="monospace">,</rich_text>
        <rich_text family="monospace" style="italic">b</rich_text>
        <rich_text family="monospace">)))</rich_text>
        <rich_text>
	</rich_text>
        <rich_text style="italic">Code Snippet:</rich_text>
        <rich_text>
	</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text weight="heavy">Euclid's Algorithm:</rich_text>
        <rich_text>
	



common divisors of a and b
a+b, a-b and a*b divisible by gcd(a,b)
gcd(a, b) , assuming a&gt;b
=gcd(a-b, b)
=gcd(a+b, b)

</rich_text>
        <codebox char_offset="416" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

ll gcd(ll a, ll b)
{
	if (a == 0)
		return b;
	return gcd(b % a, a);
}

int main()
{
	ll a, b;

	cin &gt;&gt; a &gt;&gt; b;
	cout &lt;&lt; __gcd(a, b) &lt;&lt; endl;
	cout &lt;&lt; gcd(a, b) &lt;&lt; endl;

	return 0;
}</codebox>
        <codebox char_offset="1133" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="cpp" highlight_brackets="1" show_line_numbers="1">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

ll gcd(ll a, ll b)
{
	if (a == 0)
		return b;
	return gcd(b % a, a);
}

int main()
{
	ll a, b;

	cin &gt;&gt; a &gt;&gt; b;
	cout &lt;&lt; (a * b) / __gcd(a, b) &lt;&lt; endl;
	cout &lt;&lt; (a * b) / gcd(a, b) &lt;&lt; endl;

	return 0;
}</codebox>
      </node>
    </node>
    <node name="Data Structures" unique_id="8" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1669300304" ts_lastsave="1669300321"/>
    <node name="Algorithms" unique_id="9" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="1" foreground="" ts_creation="1669300335" ts_lastsave="1669300342"/>
  </node>
</cherrytree>
